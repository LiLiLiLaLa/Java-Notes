一.抽象类的定义及使用
定义：抽象类只是比普通类多了一些抽象方法而已。
抽象方法：只声明未实现的方法（没有方法体），抽象方法必须使用abstract来定义，并且抽象方法所在的类也要用abstract来定义。
注：抽象方法只声明未实现，只声明未实现的却不一定是抽象方法eg:本地方法（native）
1.抽象方法使用原则
A.所有抽象方法必须有子类
考点：abstract和final不能同时出现
B.抽象类的子类必须覆写抽象类的所有抽象方法
考点：private和abstract不能同时出现
C.抽象类无法直接创建实例化对象，需要子类向上转型为其实例化

2.抽象类相关约定
A.抽象类一定存在构造方法，子类也一定遵循对象实例化流程，先调用父类构造再调用子类构造
B.抽象类可以没有任何抽象方法，但是此时任然不能直接创建实例化对象
C.final和private都不能和abstract同时出现
D.关于内部抽象类
a.子类只需要覆写外部抽象类中的直接抽象方法即可，内部抽象类的抽象方法不需要覆写
b.如果要覆写内部抽象类的抽象方法，继承类和抽象类结构相同就好了

3.模板设计模式->AQS（同步队列）中的模板方法
开闭原则（OCP）：一个软件实体如类、模块或函数应该对扩展开放，对修改关闭。
设计模式：解耦，第三方（高内聚，低耦合）
模板（模板方法）设计模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中，模板模式可以使得子类在不改变算法的情况下，重新定义算法中的某些步骤

4.接口的定义与使用
接口优先原则：在一个操作既可以使用抽象类，又可以使用接口的时候，优先考虑使用接口。
1.接口的定义（JDK8以前）：接口就是抽象方法与全局常量的结合（纯粹版的抽象类）

2.命名规范：
A.父接口使用I开头
B.子类的命名规范：eg:接口名IMyInterFace 子类实现此接口命名为MyInterFaceImpl

3.子类要想使用接口，使用implements实现接口，一个子类可以同时实现多个父接口（避免单继承局限）

4.父接口之间相互转换：前提是两个父接口拥有共同的实现子类

5.接口的使用限制
A.接口中只允许public权限（不管常量还是方法，都是public权限，即使不写权限修饰符，默认也是public，这个条件只有接口满足）
B.阿里编码规范：接口中不要出现任何修饰符号，public也不要加
C.当子类既需要实现接口，又要继承抽象类时，请先使用extends继承一个抽象类，而后使用implements实现多个接口
D.一个抽象类可以使用implements实现多个接口，接口不能继承抽象类
E.接口可以使用extends继承多个父接口（接口多继承）

6.接口应用
a.定义操作标准
b.表示能力
c.（了解）分布式开发之中暴露远程服务方法

二.工厂设计模式
将客户端的new操作解耦到第三方，第三方起名叫工厂
1.简单工厂->产品个数少，没有家族
A.角色组成
a.一个抽象产品类（接口）
b.多个具体产品类
c.一个工厂（new操作在此工厂中进行）->客户端通过工厂类获取具体实例

B.优点：易于实现，易于解耦

C.缺点：每当有新实例产生就要添加分支，违反OCP开放封闭原则

D.eg:Spring->BeanFactory

2.工厂方法模式
1.定义一个用来创建对象的接口，让子类来决定实例化哪一个类
针对每一个产品（产品族）提供一个工厂类，客户端需要判断使用哪个工厂

2.特点：
a.一个产品抽象类
b.多个具体产品类
c.一个抽象工厂接口（针对抽象产品类）
d.多个具体工厂类（每个产品家族有自己的工厂）
eg:Spring->FactoryBean

3.抽象工厂->多个产品线混合

三.代理模式eg:Spring->AOP
特点：两个子类共同实现同一个接口，其中一个子类负责真实业务实现，另一个子类完成辅助真实业务主题的操作。
eg:
接口：买口红
真是主题类：你
代理类：代购