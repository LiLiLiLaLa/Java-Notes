1.线程同步
同步问题：每一个线程对象轮番抢占共享资源带来的问题

1.1.同步处理
1.1.1.使用synchronized关键字来处理同步问题
synchronized处理同步有两种模式：同步代码块，同步方法
同步代码块：要使用同步代码块，必须要设置一个锁定的对象，一般可以锁当前对象this
同步方法：在方法上加synchronized关键字，表示此方法只有一个线程能进入，隐式锁对象，this

1.1.2.synchronized底层实现
1.1.2.1.同步代码块：
锁类的实例对象    synchronized(this){}
锁类对象（class对象）synchronized(类名称.class){}――>全局锁
任意实例对象   String lock = "";
                       synchronized(lock){}

1.1.2.2.同步方法
普通方法+synchronized:锁的是当前对象
静态方法+synchronized:锁的是类―>全局锁，效果等同于同步代码块的锁类对象

1.1.3.对象锁（monitor）机制―>JDK6之前的synchronized（重量级锁）
同步代码块：执行同步代码块后首先要执行monitorenter指令，退出时执行monitorexit指令。

使用内建锁（synchronized）进行同步，关键在于要获取指定锁对象monitor对象，当线程获取monitor后才能继续向下执行，否则就只能等待。这个获取过程是互斥的，即同一时刻只有一个线程能够获取到对象monitor。

通常一个monitorenter指令会包含若干个monitorexit指令，原因在于JVM要确保锁在正常执行路径和异常执行路径都能正常的解锁。

同步方法：当使用synchronized标记方法时，编译后的字节码中方法的访问标记多了一个ACC_SYNCHRONIZED。该标记表示，进入该方法时，JVM需要进行monitorenter操作，退出该方法时，无论是否正常退出，JVM需要进行monitorexit操作。

当执行monitorenter时，如果目标锁对象的monitor计数器为0，表示此对象没有被任何其他对象所持有，此时JVM会将该锁对象的持有线程设置为当前线程，并将计数器+1；如果目标锁对象的计数器不为0，判断目标锁对象的持有持有线程是不是当前线程，如果是再次将计数器+1（锁的可重入性），如果锁对象的持有线程不是当前线程，当前线程需要等待，直到持有线程释放锁。

当执行monitorexit指令时，JVM会将锁对象的计数器-1，当计数器减为0时，表示该锁对象已经被释放。

写代码证明锁的可重入与互斥


















