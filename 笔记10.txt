JDK1.5新特性
1.方法的可变参数
设计一个方法可以接收任意个数的整数，并返回他们的想加结果

//传统方法
public static int add(int[] data){
    int result = 0;
    for(int tmp:data){
        result+=mp;
    }
     return result;
}
语法：数据类型 ... 可变参数名称
int ... data
//可变参方法
public static int add(int ... data){
    int result = 0;
    for(int tmp:data){
        result+=mp;
    }
     return result;
}
可变参的本质上是数组，一个方法中只允许一个可变参数，并且可变参一定是方法最后一个参数。

1.2 for each循环：只能用于数组、类集内容的取得，不能修改数组、类集内容
for(数据类型 临时变量：数组名/类集名)
for(int tmp:data)

1.3静态导入：将一个类的所有静态域（包括静态属性方法） ，全部导入到使用类中，此时的调用属性和方法不再需要类名

2.泛型->守门员（出于安全性考虑，不再有类型转换异常）
2.1泛型类
所谓的泛型指的是在类定义的时候并不会设置类中的属性或方法的参数类型，而是在类使用时再定义。

class MyClass<T>{
        T value;
}
//<>中的T被称为类型参数，用于指代任何类型，T只是个占位标记
出于规范起见，类型参数一般用大写的字母来表示
T:用在模型类声明上，指代泛型类
E:一般用于属性
K,V:键值对
当泛型需要多个不同类型变量时，<>中用“,”隔开eg:<T,E>
泛型的出现彻底解决了向下转型出现的ClassCastException问题
泛型只能用引用数据类型，不能用基本数据类型

2.2泛型方法
语法：public <T> void method(T t){
}
当泛型类与泛型方法共存时，泛型方法中的类型参数与泛型类的参数无关，泛型方法始终以自己的类型参数为准，规范起见，当泛型类与泛型方法共存时，请使用不同的类型参数来区分彼此

2.3通配符->解决泛型参数统一化问题
2.3.1？通配符->作用于方法参数声明
public static void print(MyClass<?> myClass)
此时方法参数表示可以接收任何类型的MyClass对象
由于无法确定入参类型，因此？通配符下的泛型参数，只能取得类中属性值，无法进行属性值设置

2.3.2设置泛型上限->用于泛型类声明，也可用于方法参数类声明：T extends 类(T  <= 类)
方法参数：？ extends类
eg:? extends Number：表示方法参数只能接收Number及其子对象
方法参数设置泛型上限任然只能取得类中属性值，而无法设置，因为设置父类值子类不一定能使用（父类不一定能向下转型变为子类00）

3.2.3设置泛型下限->只能用于方法参数
？ super 类（>=类）
表示方法入参只能接收类以及其父类对象
方法 参数设置泛型下限不仅可以取得类重中属性值，还可以设置属性值，子类可以天然向上转型变为父亲

2.4泛型方法
2.4.1
2.4.2

2.5泛型擦除：
泛型类进入JVM之前，会进行类型擦除，泛型类的类型参数如果没有指定类型上限，则被擦成Object类，如果类型参数指定类型上限，擦除为指定参数类型   

3.枚举
java中枚举使用enum关键字定义枚举->枚举是一种多例设计模式

enum Color{
    RED,GREEN,BLUE;
}//本质上是个Enum类
3.1Enum类
JDK1.5新增的enum枚举结构并不是新的结构。使用enum定义的枚举本质上是一个类，默认继承java.lang.Enum类
取得枚举名称：name方法

public final String name();
取得枚举编号：ordinal方法

public final int ordinal();
取得所有枚举对象：values方法

枚举类.values():Enum[]
enum和Enum区别

3.2.枚举中定义其他结构，枚举对象必须放在首行声明（语法要求）
枚举中的构造防范必须私有（因为枚举是多例模式）
枚举还可以实现接口，此时枚举中的每个对象都成了接口对象

4.注解（Annottion）@interface
4.1准确覆写@Override
作用：检查当前类中的覆写方法与父类定义的同名方法是否相同，如果有任何一个地方不同，编译报错

4.2过期处理@Deprecated
场景：原有类或者方法在旧版本没有问题但是在新版本不推荐使用，可以加上@Deprecated注解，明确表示不建议用户使用此类

4.3.压制警告@SuppressWarnings
当调用某些操作可能产生问题的时候就会出现警告信息，但是警告信息并不是异常（Exception）。

5.JDK1.8新特性
5.1可以使用default来定义普通方法（此时default不可省），需要通过对象来调用。

5.2可以使用static来定义静态方法，通过接口名来调用。

6.Lambda表达式：函数式编程
要想使用函数式编程必须有一个前提：接口中只有一个方法，如果接口中存在两个以上的方法，无法使用函数式编程的语法，如果现在某个接口就是为了实现函数式编程而生，@FuncationalInterface定义在接口上，检查此接口是否只存在一个方法。
lambda表达式语法：

单行无返回值、单行有返回值
()->...方法代码；
10
多行有返回值：
()->{
   ...
   ...
   return 返回值语句
}；
