如何证明读到了HTTP的报头？读到空行
如何知道正文有多长？必须知道正文有多长，防止多读或少读（粘包问题），所以通过Header的Content-length属性字段
如何知道正文类型？Content-Type属性字段
location + URL：接下来去哪
    永久性重定向：只跳转一次
    临时性重定向：每次都要跳转
查看网络连接：netstat
查看端口号：ifconfig
查看进程：ps -aux
查看进程ID：pidof 进程名

1.UDP协议（传输层）
UDP头部长度固定（8个字节），源端口号、目的端口号、16位UDP长度、16位UDF校验和

1.1.UDP特点
√无连接：知道对端的IP和端口号就直接进行传输，不需要建立连接，不耗费资源
√不可靠：没有确认机制，没有重传机制，如果因为网络故障该字段无法发到对方，UDP协议层也不会给应用层返回任何错误信息，但是它简单且快
√面向数据报：不够灵活的控制读写数据的次数和数量，人家发什么怎么发你就怎么接收

1.2.UDP没有发生缓存区，但是有接收缓存区

1.3.全双工：两个人可以同时收发
半双工：一个收一个发

2.TCP协议：传输层协议，要对数据的传输进行一个详细控制

状态机：什么状态做什么事情

TIME_WAIT：确定对方收到最后确认序号回收过程正确，尽可能防止断开连接时路径上还有没传完的数据所以等待一段时间
CLOSE_WAIT：

2.1.滑动窗口：解决串行发送的效率
窗口大小指的是无需等待确认可以继续发送数据的最大值
滑动窗口在发送缓冲区，是发送缓冲区的一部分
滑动窗口大小由什么决定？拥塞窗口和对方接受能力的较小值

客户端发送发连续收到三次相同的确认，就要进行快重传。

为什么已经有了超时重传还要进行快重传？
超时重传应对只发送了一组数据时只会有一个应答，无法进行快重传，但是快重传在发送数据组数多时效率很高。

2.2.流量控制：TCP根据接收端的处理能力来决定发送端的发送速度，这种机制叫做流量控制（解决可靠性问题）
窗口探测机制：当发回来的窗口大小变为0时，过了重发超时的时间还未接收到窗口更新通知，发送端会发送一个窗口探测的包

2.3.拥塞控制：少量数据丢失就进行超时重传就好，如果大量丢失就认为网络拥塞，进行拥塞控制（解决网络拥塞，防止大量数据丢失，保证可靠性）
慢启动：先发送少量的数据探测网络情况，呈指数增长
拥塞窗口：表达的是数据在网络上传达的能力 

2.4.延迟应答（解决效率问题）
窗口越大，网络吞吐量越大，传输效率越高

2.5.捎带应答（ 解决效率问题）

 *****TCP三个特殊情况********
1.TCP面向字节流――读的过程和发的过程无关（UDP面向数据报――怎么发怎么读）
2.粘包问题：多读少读等造成的问题（应用层读取时明确各个“包”的边界）
实质上传输过程中，传输层并不知道自己发送接收的内容是什么，他们的读取与解释要依靠应用层。
3.TCP异常情况
进程终止：连接本身和文件差不多，进程退出时，它建立的连接也要被自动释放（意味着在操作系统底层要进行四次挥手，和正常退出没什么区别）
机器重启：和进程终止一致
机器断网或断电：服务器短期内认为连接还在
长连接


全连接队列：accept队列


















