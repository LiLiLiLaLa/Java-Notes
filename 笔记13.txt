线程操作的类在Object类中：任意对象都有一个同步队列即等待获取对象的monitor，任何对象都有监视器，任何一个对象都可以等待。

1.生产-消费者问题
1.1.wait()方法
作用：使得当前线程立刻停止运行，处于等待状态（wait），并将当前线程置入锁对象的等待队列中，直到被通知（notify()）或被中断为止。

使用条件：只能在同步方法或同步代码块中使用，必须是内建锁。

wait()调用后立即释放内建锁。

public final void wait() throws InterruptedException：痴汉方法1.0版本――死等，直到被唤醒或中断

public final void wait(long timeout) throws InterruptedException：痴汉2.0，超时等待，若规定时间内没被唤醒则线程退出，单位毫秒

public final void wait(long timeout) throws InterruptedException：在上个方法的基础上增加了纳秒控制

1.2.notify()（痴汉等待的姑娘）
语意：唤醒处于等待状态的线程

使用条件：notify()也必须在同步方法或同步代码块中调用，用来唤醒等待该对象的其他线程，如果有多个线程等待，随机挑选一个被唤醒。（抛绣球）

notify()方法调用后，当前对象不会立马释放对象锁，要等到当前线程执行完毕后再释放锁

1.3.notifyAll()：唤醒（该对象）所有处于等待状态的线程

1.4.线程由运行态―>阻塞（wait）
1.4.1.调用sleep(),立刻交出CPU，++++++++++++++++++++++++++++++++++++++++++++++++++++++++不释放锁
1.4.2.线程调用阻塞式IO（BIO）方法
1.4.3.线程获取锁失败进入阻塞状态
1.4.4.线程调用wait()
1.4.5.线程调用suspend()，将线程挂起（一般不常用，容易造成死锁）

每个锁对象都有两个队列，一个等待队列一个同步队列，同步队列存储获取锁失败的线程，等待队列存储调用wait()等待的线程，将线程唤醒实际上是将处于等待队列的线程移动到同步队列去竞争锁









































1