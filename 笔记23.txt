垃圾回收算法
1.标记-清除算法
A.算法核心思想：整个算法分为标记和清除两个阶段，标记阶段标记出此次垃圾回收需要回收的对象，清除阶段一次性清除所有标记对象。

B.问题：a.效率：标记与清除两个阶段的效率都不高
b.空间问题：标记清除算法会产生大量不连续空间，若程序中需要分配较大连续对象时，由于空间碎片较多无法找到连续内存而不得不再次出发GC

2.复制算法――Java新生代垃圾回收算法
A.核心思想：将内存按容量划分为大小相等的两块，每次只使用其中一块内存。当使用的内存需要进行垃圾回收时，会将此区域的所有存活对象一次性复制到保留区域，然后将使用的内存块一次清理掉

B.复制算法最大的问题在于内存的利用率太低。商用JVM都对复制算法进行了改进。

C.改进后的复制算法
新生代中98%的对象都是“朝生夕死”（存活时间非常短），所以并不需要按照1:1划分内存空间。将内存（新生代）分为一块较大的Eden（伊甸园）和两块较小的Survivor（幸存者，两块大小一样，一块成为From区一块成为To区）空间。每次只使用Eden和其中一块Survivor（默认8:1:1）。
HotSpot算法流程：a. 当Eden区快满的时候，会触发第一次MiNor GC，将所有存活对象拷贝到Survivor的From区域中，然后一次性清除Eden区；当Eden区再次出发Minor GC，会扫描Eden区和From区，将这两块空间中的存活对象拷贝到To区，然后一次性清除Eden区和From区
b. 当后续Eden区再次发生Minor GC时，会对Eden区和To区进行扫描，存活对象移回From区，清空To区。后续流程类似，只是将From区和To区轮流作为保留区。
c. 部分对象会在From与To区中来回复制，如此交换15次（MaxTenuringThreshold，默认为15）最终会存入老年代。

Suvivor对象若无法放下所有存活对象，需要依赖其他内存（如老年代内存）进行分配担保。

3.标记整理算法（老年代的GC算法）
老年代中对象存活率很高，因此不适用复制算法（需要大量对象的复制过程，效率很低）

算法思想：算法分为标记与整理两个阶段。标记过程与标记清除过程一致，整理过程需要让所有存活对象向一端移动，然后直接清理掉存活对象边界以外的内存

****4.分带回收算法（Java）****
算法核心思想：根据对象的存活周期将内存（堆内存）划分为以下两块
a. 新生代：每次GC都有大批对象死去，只有少量存活，因此采用复制算法

b. 老年代：对象存活率高，没有额外空间对其分配担保，采用标记-整理算法

****Minor GC和Full GC****
a. Minor GC成为新生代GC：指的是发生在新生代的垃圾回收。由于新生代对象大多存活周五段，因此Minor GC发生频率非常频繁，一般回收速度也较高。

b. Full GC成为老年代GC或者Major GC：指的是发生在老年代的垃圾回收。出现了Major GC通常会伴随至少一次的Minor GC（并非绝对）。一般Full GC比Minor GC慢10倍以上，发生频率低。

5.垃圾收集器（垃圾回收算法的具体实现）――JDK8
串行：垃圾回收线程与用户线程在JVM中顺序进行
并行：多个垃圾回收线程一起执行，用户线程仍处于等待状态
并发：垃圾回收线程与用户线程一起执行

新生代垃圾回收器：Serial（串行）、ParNew（并行）、Parallel Scavenge（并行）

老年代垃圾回收器：CMS（并发）、Serial Old（串行）、Parallel Old（并行）

全区域垃圾回收器：G1（并发）

STW：当垃圾回收线程工作时，用户线程处于等待状态

6.对象分配策略
6.1.对象优先在Eden区分配
-Xss：设置栈值
-Xms：设置堆最小值
-Xmx：设置堆最大值
-Xmn：设置新生代内存大小
-XX:SuvivorRatio=9     修改新生代内存比为9 : 0.5 : 0.5

大多数情况下，对象在新生代Eden区分配空间，当Eden区没有足够的分配时，JVM发生一次Minor GC

6.2.大对象直接进入老年代
-XX:PretenureSizeThreshold=字节大小   超过这个字节大小的对象直接进入老年代

6.3.长期存活对象进入老年代
JVM给堆中每个对象定义了一个对象年龄计数器。若对象在Eden出生并且经历一次Minor GC后仍然存活并且能被Survivor容纳，将此对象年龄置为1，此后对象每次在Survivor经历一次Minor GC，年龄就增加一岁。当其年龄增加到一定程度（默认为15），此对象晋升到老年代。

-Xx:MaxtenuringThreshold

6.4.动态年龄的判断（优先级高于长期存活对象）
JVM并不是永远要求对象年龄到达MaxtenuringThreshold才能晋升老年代。若Survivor空间中相同年龄的所有对象的总和大于一块Survivor空间的一半，此时年龄大于等于该年龄的所有对象直接进入老年代。无须等到MaxtenuringThreshold要求的年龄。

7.JDK命令行工具
***7.1.jps：JVM进程状态工具***
列出正运行的JVM进程，并返回进程ID
jps -l：输出.....(什么东西没听见，回头自己查一下)，回进程ID

7.2.jstat：JVM统计信息监视工具
显示本地或远程JVM中类装载、内存、垃圾回收等数据

jstat -gcutil PID：显示（PID代表进程的）垃圾回收信息

7.3.jinfo：JVM配置信息查看工具

jinfo -flags PID

****7.4.jmap：内存映像工具（查看Java堆具体信息）****
jmap由于生成堆转储快照（堆的快照）

jmap -heap PID：显示堆的具体信息

jmap -histo PID：显示堆中对象统计信息

7.5.jhat：heap文件的分析工具
jhat heap文件路径

***7.6.jstack Java栈跟踪工具***
jstack生成当前JVM线程快照，可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环等

8.Java内存模型（JMM）――基于线程的内存模型
JMM定义的主要目标：为了定义程序中各个变量的访问规则（JVM中，如何将变量从内存中取出以及如何将变量再写回内存中等细节）。此处的变量包括实例字段、静态字段与数组元素。

8.1.主内存（所有线程共享）与工作内存（每个线程独有）
JVM规定所有变量必须存储在主内存中，每条线程都有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存变量。不同线程之间也无法直接访问彼此的工作内存变量。线程间的变量值的传递均需要通过主内存来完成。

8.2.内存间交互操作

8.3.JMM内存三大特性
原子性（一组行为要么全部发生要么全部不发生）：基本数据类型的访问读写是具备原子性的。如若需要更大范围的原子性，需要内键锁或lock体系的支持（如i++,i--等操作）

可见性：当一个线程修改了共享变量的值，其他线程能够立即得知此修改。volatile、final、synchronized可以实现可见性

有序性：若在本线程内观察，所有操作都是有序的，若在线程之外观察另一个线程，所有操作都是无序的
JMM具备先天的有序性，即无需通过任何手段就能保证的有效性。成为JMM的happens-before原则。若两个操作的次序无法从happens-before中推导出来，则无法保证其有序性，JVM可以随意对其排序。

要想并发程序正确的执行，必须同时保证原子性、可见性及有序性，只要有任何一个没有被保证，就可能导致程序运行不正确

锁定规则：解锁操作先于上锁操作
volatile变量规则：对一个变量的写操作先于对他的读操作
对象终结规则：对象初始化操作先于它的finalize()操作

8.4.Volatile变量的特殊规则
8.4.1.第一：保证此变量对所有线程的可见性
当一条线程修改了这个变量的值，新值对于其他变量来说是可以立刻得知的，普通变量无法做到可见性（因为对于volatile变量写操作先于读操作）。

volatile变量在各个线程中是一致的，但是volatile变量的运算在并发下一样是不安全的。Java中运算操作并非原子操作，必须结合内键锁和Lock体系来约束。

由于volatile只保证可见性，所有在不符合以下两个规则的场景下，仍需要使用加锁来保证原子性：
a.运算结果不依赖当前的值或确保只有单一的线程修改变量值
b.变量不需要与其他的状态变量共同参与不变约束（不依赖其他值，如x = y就不能保证原子性）

并发场景下对于类似i++操作如何保证程序的正确结果：
a.加锁
b.使用原子类（java.util.atomic包下所有的类――内部使用CAS保证原子性）

8.4.2.第二：禁止指令重排（内存屏障――一堵墙）
a.当程序执行到volatile变量的读或写操作时，在其前面的更改肯定全部已经执行完毕且结果已经对后面可见，在其后面的操作肯定还没执行
b.在进行质量优化时，不能将volatile变量访问的语句放在其后面执行，也不能放在前面执行

懒汉式单例的线程安全问题
singleton = new Singleton();
a.在堆上分配空间
b.属性初始化
c.引用指向对象
a->b->c
指令重拍a->c->b
优化：double checked，double锁，双重加锁单例模式

class Singleton {
    private static volatile Singleton singleton;
    private Singleton(){}
    public String getStr() {
        return str;
    }
    public static Singleton getInstance() {
        if (singleton == null) { // single checked
            synchronized (Singleton.class) {
                if (singleton == null) { // double checked
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
