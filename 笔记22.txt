JVM简介
JVM内存区域划分――>判断对象是否存活――>垃圾回收算法――>垃圾回收器――>JVM性能检测
六块内存分别做什么？放什么东西？
六块内存会产生哪些异常？
-XX:printGC

1.虚拟机：通过软件模拟的、具有完整硬件功能、运行在完全隔离环境中的计算机系统。
eg：VMWare，Virtual Box

JVM是通过软件模拟Java字节指令集，JVM只保留了PC寄存器，而普遍的虚拟机有很多寄存器

JVM还可以跑：Scala等

单核CPU实现多线程：每个具体时刻只有一个线程抢占处理器资源，只不过轮询时间快，使用者无法察觉

2.栈内存：局部变量，方法栈帧
堆内存：全局变量，静态变量等

3.JVM内存划分―――共6块内存（从JDK1.3至今，HotSpot为默认JVM，本划分方法基于HotSpot）：
3.1.线程私有内存（三块）：每个线程都有，彼此线程之间相互隔离
3.1.1程序计数器：是比较小的内存空间，当前线程所执行的字节码的行号指示器。
A：记录内容：当前线程执行Java方法，程序计数器记录的是正在执行的Java字节码指令地址，若当前线程执行的是Native方法，计数器值为空。
B：程序计数器是唯一一块不会产生OOM异常的区域

3.1.2.虚拟机栈（Java的方法栈）：描述Java方法执行的内存模型
A：每个方法执行的同时都会创建一个栈帧来存储局部变量表、操作数栈和方法出口。每个方法从调用直到执行完毕的过程就对应着一个栈帧在虚拟机栈的入栈出栈过程。
B：其生命周期与线程相同：在创建线程同时创建此线程的虚拟机栈，线程执行结束，虚拟机栈与线程一同被回收。
C：产生异常（2种）：a.若当前线程请求事务栈深度大于JVM允许的深度（-Xss设置栈容量），抛出StackOverFlowError异常（常见于单线程情况下）。
b.虚拟机在进行栈的动态扩展时，若无法申请到足够的内存，会抛出OOM（OutOfMemoryError）（常见于多线程情况下）。

3.1.3.本地方法栈：本地方法（Native方法）执行的内存模型
其他和虚拟机栈完全一样
HotSpot虚拟机中，本地方法栈与虚拟机栈是一块内存

3.2.线程公有内存（三块）：所以线程共享此内存空间，此内存空间对所有线程可见
3.2.1.堆（GC堆）
A：Java堆（Java Heap）是JVM管理的最大内存区域，在JVM启动时创建，所有线程共享此内存，此内存中存放的都是对象实例以及数组。Java堆是垃圾回收器管理的最主要的内存区域。Java堆可以处于物理上不连续的内存空间。（-Xmx设置堆最大值，-Xms设置堆最小值）
B：产生异常：若在堆中没有足够内存完成对象实例分配并且堆无法再次扩展时，抛出OOM异常。

3.2.2.方法区：用于存储已被JVM加载的类信息、常量、静态变量等数据。JDK8以前，方法区也叫永久带，JDK8以后称为元空间（Meta Space）
A：产生异常：方法区无法满足内存分配需求时抛出OOM

3.2.3.运行时常量池：是方法区的部分，存放字面量与符号引用
A：字面量：字符串常量（JDK1.7以后移到堆中）、final常量、基本数据类型的值
B：符号引用：类、字段、方法的完全限定名（包名.类名）、名称、描述符

4.对象产生：符号引用―>类―>具体引用

5.OOM分两种情况：
内存溢出：内存中的对象确实还应该活着，但由于堆内存不够产生的异常
内存泄漏：无用对象无法被GC

6.判断对象是否已死
6.1.引用计数法
6.1.1.算法思想：给每个对象附加一个引用计数器，每当有一个地方引用此对象时，计数器+1，每当有一个引用时效时，计数器-1，在任意时刻，只要计数器值为0的对象就是不能再被使用的，即对象已死。
6.1.2.优缺点：引用计数法实现简单，判断效率也较高。Python使用引用计数法来管理内存。但是无法解决循环引用问题，因此JVM并未采用此算法。

6.2.可达性分析算法：Java（C#、Lisp）采用可达性分析算法来判断对象是否存活
6.2.1.算法思想：通过一系列叫做“GC Roots”的对象作为起点，从这些节点开始向下搜索对象，搜索走过的路径，称为“引用链”，当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到对象不可达），证明此对象已死。
6.2.2.Java中能做完GC Roots的对象包含以下四种：
A：虚拟机栈中引用的对象
B：类静态变量引用的对象
C：常量引用的对象
D：本地方法栈中引用的对象

******6.3.引用*****
在JDK1.2以前，Java中引用的定义很传统 : 如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义有些狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态。我们希望能描述这一类对象 : 当内存空间还足够时，则能保存在内存中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。很多系统中的缓存对象都符合这样的场景。在JDK1.2之后，Java对引用的概念做了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)四种，这四种引用的强度依次递减。
6.3.1.强引用（Strong Reference）：指的是代码中普遍存在的，类似于Object obj = new Object();在JVM中，只要强引用还存在，垃圾回收器永远不会回收此对象实例。
6.3.2.软引用（Soft Reference）：用来描述一些有用但不必须对象，对于仅被软引用指向的对象，在系统将要发生内存溢出之前，会将所有软引用对象进行垃圾回收。若内存够用，这些对象仍然保留。在JDK1.2之后提供SoftReference来实现软引用。
6.3.3.弱引用（Weak Reference）：强度比软引用更差一点。仅被弱引用关联的对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作时，无论当前内存是否够用，都会回收掉仅被弱引用关联的对象。JDK1.2之后使用WeakReference来实现弱引用。
6.3.4.虚引用（Phantom Reference）：也称为幽灵引用或幻影引用，是最弱的一种引用关系，一个对象是否有虚引用存在完全不会对其生存时间产生影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前收到一个系统通知。JDK1.2之后，提供PhantomReference来描述虚引用。

6.4.对象自我拯救――finalize
protected void finalize() throws Throwable{}
在可达性分析算法中不可达的对象，也并非“非死不可”，所有不可达的对象处于“缓刑”阶段。要宣告一个对象彻底死亡，需要经历两次标记过程：
若对象在进行可达性分析之后发现GC Roots不可达，此对象会进行第一次标记并且进行一次筛选过程。筛选条件是此对象是否有必要执行finalize()，当对象没有覆盖finalize()方法或finalize()方法已被JVM调用过，JVM会将此对象彻底宣判死亡。筛选成功（对象覆写了finalize()方法并且未被执行），会将此对象放入F-Queue，如果对象在finalize()成功自救（此对象与GC Roots建立联系），则对象会在第二次被标记时被移除回收集合，成功存活，若对象在fianlize()中仍与GC Roots不可达，宣告死亡。

6.5.方法区的回收：方法区回收掉的主要是两部分内容：废弃常量和无用的类
6.5.1.回收废弃的常量
回收废弃常量和回收Java堆中的对象十分类似。以常量池中字面量(直接量)的回收为例，假如一个字符串"abc"已经进入了常量池中，但是当前系统没有任何一个String对象引用常量池的"abc"常量，也没有在其他地方引用这个字面量，如果此时发生GC并且有必要（内存不够）的话，这个"abc"常量会被系统清理出常量池。
6.5.2.判断一个类是否为无用类的三个条件
A： 该类的所有实例都已经被回收（Java堆中不存在该类的任何实例）
B：加载该类的类加载器已被回收
C：该类的class对象没有在任何其他地方被引用，也无法通过反射访问该类的所以内容
满足以上三个条件才可能被回收


