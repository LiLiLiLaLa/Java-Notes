1.线程同步
同步问题：每一个线程对象轮番抢占共享资源带来的问题


1.1.同步处理
1.1.1.使用synchronized关键字来处理同步问题
synchronized处理同步有两种模式：同步代码块，同步方法
同步代码块：要使用同步代码块，必须要设置一个锁定的对象，一般可以锁当前对象this
同步方法：在方法上加synchronized关键字，表示此方法只有一个线程能进入，隐式锁对象，this

1.1.2.synchronized底层实现
1.1.2.1.同步代码块：
锁类的实例对象    synchronized(this){}
锁类对象（class对象）synchronized(类名称.class){}——>全局锁
任意实例对象   String lock = "";
                       synchronized(lock){}

1.1.2.2.同步方法
普通方法+synchronized:锁的是当前对象
静态方法+synchronized:锁的是类—>全局锁，效果等同于同步代码块的锁类对象

1.1.3.对象锁（monitor）机制—>JDK6之前的synchronized（重量级锁）
同步代码块：执行同步代码块后首先要执行monitorenter指令，退出时执行monitorexit指令。

使用内建锁（synchronized）进行同步，关键在于要获取指定锁对象monitor对象，当线程获取monitor后才能继续向下执行，否则就只能等待。这个获取过程是互斥的，即同一时刻只有一个线程能够获取到对象monitor。

通常一个monitorenter指令会包含若干个monitorexit指令，原因在于JVM要确保锁在正常执行路径和异常执行路径都能正常的解锁。

同步方法：当使用synchronized标记方法时，编译后的字节码中方法的访问标记多了一个ACC_SYNCHRONIZED。该标记表示，进入该方法时，JVM需要进行monitorenter操作，退出该方法时，无论是否正常退出，JVM需要进行monitorexit操作。

当执行monitorenter时，如果目标锁对象的monitor计数器为0，表示此对象没有被任何其他对象所持有，此时JVM会将该锁对象的持有线程设置为当前线程，并将计数器+1；如果目标锁对象的计数器不为0，判断目标锁对象的持有持有线程是不是当前线程，如果是再次将计数器+1（锁的可重入性），如果锁对象的持有线程不是当前线程，当前线程需要等待，直到持有线程释放锁。

当执行monitorexit指令时，JVM会将锁对象的计数器-1，当计数器减为0时，表示该锁对象已经被释放。

写代码证明锁的可重入与互斥

2.CAS：Compare and Swap（ 比较交换机制）—>乐观锁
悲观锁：假设每一次执行，同步代码块均会产生冲突，所以当线程获取锁成功会阻塞其他尝试获取该锁的线程（JDK1.6之前的内建锁）
乐观锁：假设所有线程访问共享资源时不乐观锁状态下不会出现阻塞状态
CAS是乐观锁（无锁操作），无所操作使用CS（比较交换）来判断是否出现冲突，出现冲突就重试当前操作直到不冲突为止
2.1.CAS操作过程
一般来讲，CAS交换过程分三个阶段（V，O，N）
V:内存中地址存放的实际值
O:预期值（旧值）
N:更新后的值
当执行CAS后，当V==O，即旧值和内存中实际值相等，表示上次修改后没有任何线程再次修改此值，因此可将N替换到内存中，如果V!=O，表示内存中的值已经被其他线程修改，所以无法将N替换，返回最新的V值。
当多个线程使用CAS操作同一变量时，只有一个线程会成功，并成功更新变量值，其他线程会失败，失败线程会重新尝试或把线程阻塞(挂起)。

元老级内建锁（Synchronized）最主要的问题：当存在线程竞争情况下会出现线程阻塞以及唤醒带来的性能问题，对应互斥同步（阻塞同步），效率降低。而CAS并不是武断地将线程挂起，而是会尝试若干次CAS操作，并非进行耗时的挂起与唤醒操作，因此非阻塞式同步。

2.2.CAS问题
2.2.1.ABA问题
解决思路：沿用数据库的乐观锁机制，添加版本号1A->2B->3A，JDK1.5提供atomic包下AtomicStampedeReference来解决CAS的ABA问题

2.2.2.自旋（CAS）会浪费大量的处理器资源（CPU），与线程阻塞相对比，自旋会浪费大量CPU资源，因为此时线程仍处于运行状态，只不过跑的是无用指令，期望在无用指令时，锁能被释放出来。

解决方案：自适应自旋。根据以往自旋等待时能否获取到锁来动态调整自旋时间（循环尝试的数量），如果在上一次自旋时获取到锁，则此次自旋时间长一点，如果上一次自旋结束还没有获取到锁，此次自旋时间短一点

2.2.3.公平性
处于阻塞状态的线程无法立刻竞争被释放的锁，而处于自旋状态的线程很可能先获取到锁。内建锁无法实现公平性。lock体系可以实现公平锁。

3.Java对象头
JDK1.6之后对内建锁做了优化（新增偏向、轻量级锁）
无锁状态 0 01
偏向锁1 01
轻量级锁00
重量级锁（JDK1.6之前）10
这四种状态随着竞争情况逐渐升级，锁可以升级不能降级，为了提高获得锁与释放锁的效率。

3.1.偏向锁
概念：最乐观的锁，从始至终只有一个线程请求一把锁

偏向锁获取：当一个线程访问同步代码块并获取锁时，会在对象头和栈帧中的锁记录中记录存储偏向锁的线程ID，以后该线程再次进入同步块时，不需要 CAS来加锁和解锁，只需简单测试一下对象头的mark word中偏向线程ID是否是当前线程的ID，如果成功，表示线程已经获取到锁直接进入代码块运行。如果测试失败（不是当前线程ID），检查当前偏向锁字段是否为0，如果为0，将偏向锁子端设置为1（采用CAS操作），并且更新自己的线程ID到mark word字段中。如果为1，表示此事偏向锁已经被别的线程获取，则次线程需要不断尝试使用CAS获取偏向锁，或者将偏向锁撤销，升级为轻量级锁，一般情况下后者（升级）概率较大。

偏向锁撤销：偏向锁使用一种等待竞争出现才释放锁的机制，当有其他线程尝试竞争偏向锁时，持有偏向锁的线程才会撤销偏向锁。

注：偏向锁的撤销开销大，需要等待线程进入全局安全点safepoint（当前线程在CPU上没有执行任何有用字节码）。
录屏：21:00

偏向锁从JDK6后默认开启，但是在应用程序启动几秒后在激活
-XX：BiasedLockingStartupDelay = 0,将延迟关闭，JVM一启动就激活偏向锁。
-XX：-UserBiasedLocking = false,关闭偏向锁，程序默认进入轻量级锁。

3.2.轻量级锁
概念：多个线程在不同时间段请求同一把锁，也就是基本不存在锁竞争，针对此种情况，JVM采用轻量级锁来避免线程的阻塞及唤醒。

加锁：线程在执行同步代码块之前，JVM先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的mark word字段直接复制到此空间中，然后线程尝试使用CAS将对象头的mark word替换为指向锁记录的指针（指向当前线程），如果成功表示获取到轻量级锁，如果失败，表示其他线程竞争轻量级锁，当前线程便采用自旋来不断尝试。

释放：解锁时会使用CAS将复制的mark word替换回对象头，如果成功，表示没有竞争发生，正常解锁，如果失败，表示当前锁所存在竞争，进一步膨胀为重量级锁。

重量级锁会阻塞、唤醒请求加锁的进程，，针对的是多个线程同一时刻竞争同一把锁的情况，JVM采用自适应自旋来避免线程在面对非常小的同步块时，仍会被阻塞以及唤醒。轻量级锁采用CAS操作，将锁对象的标记字段替换为指向线程的指针，存储着锁对象原本的标记字段。针对的是多个线程在不同时间段申请同一把锁的情况。偏向锁只会在第一次请求时采用CAS操作，在锁对象的mark_word字段中记录下当前线程ID，此后运行中持有偏向锁的线程不再有加锁过程，针对的锁仅会被同一线程持有。

















