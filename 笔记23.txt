垃圾回收算法
1.标记-清除算法
A.算法核心思想：整个算法分为标记和清除两个阶段，标记阶段标记出此次垃圾回收需要回收的对象，清除阶段一次性清除所有标记对象。

B.问题：a.效率：标记与清除两个阶段的效率都不高
b.空间问题：标记清除算法会产生大量不连续空间，若程序中需要分配较大连续对象时，由于空间碎片较多无法找到连续内存而不得不再次出发GC

2.复制算法――Java新生代垃圾回收算法
A.核心思想：将内存按容量划分为大小相等的两块，每次只使用其中一块内存。当使用的内存需要进行垃圾回收时，会将此区域的所有存活对象一次性复制到保留区域，然后将使用的内存块一次清理掉

B.复制算法最大的问题在于内存的利用率太低。商用JVM都对复制算法进行了改进。

C.改进后的复制算法
新生代中98%的对象都是“朝生夕死”（存活时间非常短），所以并不需要按照1:1划分内存空间。将内存（新生代）分为一块较大的Eden（伊甸园）和两块较小的Survivor（幸存者，两块大小一样，一块成为From区一块成为To区）空间。每次只使用Eden和其中一块Survivor（默认8:1:1）。
HotSpot算法流程：a. 当Eden区快满的时候，会触发第一次MiNor GC，将所有存活对象拷贝到Survivor的From区域中，然后一次性清除Eden区；当Eden区再次出发Minor GC，会扫描Eden区和From区，将这两块空间中的存活对象拷贝到To区，然后一次性清除Eden区和From区
b. 当后续Eden区再次发生Minor GC时，会对Eden区和To区进行扫描，存活对象移回From区，清空To区。后续流程类似，只是将From区和To区轮流作为保留区。
c. 部分对象会在From与To区中来回复制，如此交换15次（MaxTenuringThreshold，默认为15）最终会存入老年代。

Suvivor对象若无法放下所有存活对象，需要依赖其他内存（如老年代内存）进行分配担保。

3.标记整理算法（老年代的GC算法）
老年代中对象存活率很高，因此不适用复制算法（需要大量对象的复制过程，效率很低）

算法思想：算法分为标记与整理两个阶段。标记过程与标记清除过程一致，整理过程需要让所有存活对象向一端移动，然后直接清理掉存活对象边界以外的内存

****4.分带回收算法（Java）****
算法核心思想：根据对象的存活周期将内存（堆内存）划分为以下两块
a. 新生代：每次GC都有大批对象死去，只有少量存活，因此采用复制算法

b. 老年代：对象存活率高，没有额外空间对其分配担保，采用标记-整理算法

****Minor GC和Full GC****
a. Minor GC成为新生代GC：指的是发生在新生代的垃圾回收。由于新生代对象大多存活周五段，因此Minor GC发生频率非常频繁，一般回收速度也较高。

b. Full GC成为老年代GC或者Major GC：指的是发生在老年代的垃圾回收。出现了Major GC通常会伴随至少一次的Minor GC（并非绝对）。一般Full GC比Minor GC慢10倍以上，发生频率低。

5.垃圾收集器（垃圾回收算法的具体实现）――JDK8
串行：垃圾回收线程与用户线程在JVM中顺序进行
并行：多个垃圾回收线程一起执行，用户线程仍处于等待状态
并发：垃圾回收线程与用户线程一起执行

新生代垃圾回收器：Serial（串行）、ParNew（并行）、Parallel Scavenge（并行）

老年代垃圾回收器：CMS（并发）、Serial Old（串行）、Parallel Old（并行）

全区域垃圾回收器：G1（并发）

STW：当垃圾回收线程工作时，用户线程处于等待状态

6.对象分配策略
6.1.对象优先在Eden区分配
-Xss：设置栈值
-Xms：设置堆最小值
-Xmx：设置堆最大值
-Xmn：设置新生代内存大小
-XX:SuvivorRatio=9     修改新生代内存比为9 : 0.5 : 0.5

大多数情况下，对象在新生代Eden区分配空间，当Eden区没有足够的分配时，JVM发生一次Minor GC

6.2.大对象直接进入老年代
-XX:PretenureSizeThreshold=字节大小   超过这个字节大小的对象直接进入老年代

6.3.长期存活对象进入老年代
JVM给堆中每个对象定义了一个对象年龄计数器。若对象在Eden出生并且经历一次Minor GC后仍然存活并且能被Survivor容纳，将此对象年龄置为1，此后对象每次在Survivor经历一次Minor GC，年龄就增加一岁。当其年龄增加到一定程度（默认为15），此对象晋升到老年代。

-Xx:MaxtenuringThreshold

6.4.动态年龄的判断（优先级高于长期存活对象）
JVM并不是永远要求对象年龄到达MaxtenuringThreshold才能晋升老年代。若Survivor空间中相同年龄的所有对象的总和大于一块Survivor空间的一半，此时年龄大于等于该年龄的所有对象直接进入老年代。无须等到MaxtenuringThreshold要求的年龄。

7.JDK命令行工具
***7.1.jps：JVM进程状态工具***
列出正运行的JVM进程，并返回进程ID
jps -l：输出.....(什么东西没听见，回头自己查一下)，回进程ID

7.2.jstat：JVM统计信息监视工具
显示本地或远程JVM中类装载、内存、垃圾回收等数据

jstat -gcutil PID：显示（PID代表进程的）垃圾回收信息

7.3.jinfo：JVM配置信息查看工具

jinfo -flags PID





