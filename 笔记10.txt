1.JDK1.5新特性
1.1方法的可变参数
设计一个方法可以接收任意个数的整数，并返回他们的想加结果

//传统方法
public static int add(int[] data){
    int result = 0;
    for(int tmp:data){
        result+=mp;
    }
     return result;
}
语法：数据类型 ... 可变参数名称
int ... data

//可变参方法
public static int add(int ... data){
    int result = 0;
    for(int tmp:data){
        result+=mp;
    }
     return result;
}
可变参的本质上是数组，一个方法中只允许一个可变参数，并且可变参一定是方法最后一个参数。

1.2 for each循环：只能用于数组、类集内容的取得，不能修改数组、类集内容
for(数据类型 临时变量：数组名/类集名)
for(int tmp:data)

1.3静态导入：将一个类的所有静态域（包括静态属性方法） ，全部导入到使用类中，此时的调用属性和方法不再需要类名

2.泛型->守门员（出于安全性考虑，不再有类型转换异常）
2.1泛型类
所谓的泛型指的是在类定义的时候并不会设置类中的属性或方法的参数类型，而是在类使用时再定义。

class MyClass<T>{
        T value;
}
//<>中的T被称为类型参数，用于指代任何类型，T只是个占位标记
出于规范起见，类型参数一般用大写的字母来表示
T:用在模型类声明上，指代泛型类
E:一般用于属性
K,V:键值对
当泛型需要多个不同类型变量时，<>中用“,”隔开eg:<T,E>
泛型的出现彻底解决了向下转型出现的ClassCastException问题
泛型只能用引用数据类型，不能用基本数据类型

2.2泛型方法
语法：public <T> void method(T t){
}
当泛型类与泛型方法共存时，泛型方法中的类型参数与泛型类的参数无关，泛型方法始终以自己的类型参数为准，规范起见，当泛型类与泛型方法共存时，请使用不同的类型参数来区分彼此

2.3通配符->解决泛型参数统一化问题
2.3.1？通配符->作用于方法参数声明
public static void print(MyClass<?> myClass)
此时方法参数表示可以接收任何类型的MyClass对象
由于无法确定入参类型，因此？通配符下的泛型参数，只能取得类中属性值，无法进行属性值设置

2.3.2设置泛型上限->用于泛型类声明，也可用于方法参数类声明：T extends 类(T  <= 类)
方法参数：？ extends类
eg:? extends Number：表示方法参数只能接收Number及其子对象
方法参数设置泛型上限任然只能取得类中属性值，而无法设置，因为设置父类值子类不一定能使用（父类不一定能向下转型变为子类00）

3.2.3设置泛型下限->只能用于方法参数
？ super 类（>=类）
表示方法入参只能接收类以及其父类对象
方法 参数设置泛型下限不仅可以取得类重中属性值，还可以设置属性值，子类可以天然向上转型变为父亲

2.4泛型方法
2.4.1
2.4.2

2.5泛型擦除：
泛型类进入JVM之前，会进行类型擦除，泛型类的类型参数如果没有指定类型上限，则被擦成Object类，如果类型参数指定类型上限，擦除为指定参数类型   

















